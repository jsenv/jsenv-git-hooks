import {
  assertAndNormalizeDirectoryUrl,
  resolveUrl,
  readFile,
  urlToFileSystemPath,
  removeFileSystemNode,
  catchCancellation,
  createCancellationTokenForProcess,
} from "@jsenv/util"
import { createLogger } from "@jsenv/logger"
import { HOOK_NAMES, hookIsGeneratedByUs } from "./internal/hook.js"

export const uninstallGitHooks = async ({
  cancellationToken = createCancellationTokenForProcess(),
  logLevel,
  projectDirectoryUrl,
}) => {
  return catchCancellation(async () => {
    const logger = createLogger({ logLevel })

    projectDirectoryUrl = assertAndNormalizeDirectoryUrl(projectDirectoryUrl)

    await Promise.all(
      HOOK_NAMES.map(async (hookName) => {
        const hookFileUrl = resolveUrl(`.git/hooks/${hookName}`, projectDirectoryUrl)
        logger.debug(`seach file for git ${hookName} hook at ${urlToFileSystemPath(hookFileUrl)}`)
        let hookFileContent
        try {
          hookFileContent = await readFile(hookFileUrl)
        } catch (e) {
          if (e.code === "ENOENT") {
            logger.debug(`no file for git ${hookName} hook`)
            return
          }
          throw e
        }

        cancellationToken.throwIfRequested()
        if (hookIsGeneratedByUs(hookFileContent)) {
          logger.info(`remove git ${hookName} hook file at ${urlToFileSystemPath(hookFileUrl)}`)
          await removeFileSystemNode(hookFileUrl)
        } else {
          logger.debug(
            `ignore git ${hookName} hook at ${urlToFileSystemPath(
              hookFileUrl,
            )} because not generated by us.`,
          )
        }
      }),
    )
  }).catch((e) => {
    // this is required to ensure unhandledRejection will still
    // set process.exitCode to 1 marking the process execution as errored
    // preventing further command to run
    process.exitCode = 1
    throw e
  })
}
